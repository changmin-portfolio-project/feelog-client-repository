import PostImagePreviewElementV2 from 'components/common/posts/element/SnsPostVirtualImagePreviewElement';
import { POST_RELATION_SEARCH_TYPE } from 'const/PostConst';
import { POST_IMAGE_TYPE } from 'const/PostContentTypeConst';
import {
  POST_DETAIL_POPUP_PARAM,
  POST_DETAIL_POST_ID_PARAM,
  POST_DETAIL_PROFILE_PARAM,
  TRUE_PARAM,
} from 'const/QueryParamConst';
import { MEDIA_MOBILE_MAX_WIDTH } from 'const/SystemAttrConst';
import { useForceUpdate } from 'framer-motion';
import { MasonryPostRsp, PostRsp } from 'global/interface/post';
import {
  useContainerPosition,
  useMasonry,
  usePositioner,
  useScroller,
} from 'masonic';
import React, { useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { SEARCH_TYPE_PARAM } from 'services/appApiQueryParam';
import styled from 'styled-components';
import { hoverRoundCoverStyle } from 'styles/commonStyles';

interface Item {
  id: string;
  src: string;
  postInfo: PostRsp;
  height: number;
}

interface MasonicLayoutProps {
  snsPostList: PostRsp[];
  linkPopupInfo?: {
    isLinkPopup: boolean;
    isReplaced: boolean;
  };
  longPressToResizeNum?: number;
  searchType?: POST_RELATION_SEARCH_TYPE;
  scrapId?: string;
  actionFuncByRef?: (value: HTMLImageElement | HTMLVideoElement) => void;
  masonryKey: number;
}

const MasonicLayout: React.FC<MasonicLayoutProps> = ({
  snsPostList,
  linkPopupInfo = {
    isLinkPopup: false,
    isReplaced: false,
  },
  longPressToResizeNum,
  searchType,
  scrapId,
  actionFuncByRef,
  masonryKey,
}) => {
  const containerRef = React.useRef(null);
  const [windowWidth, windowHeight] = useWindowSize();
  const { width, offset } = useContainerPosition(containerRef, [
    windowWidth,
    windowHeight,
  ]);

  const [items, setItems] = React.useState<Item[]>([]);

  // 이미지 로딩 후 실제 높이 계산
  React.useEffect(() => {
    const loadImages = async () => {
      const promises = snsPostList.map(
        (v, i) =>
          new Promise<Item>((resolve) => {
            const img = new Image();

            const postContent = v.postContents[0];

            const masonryPostRsp: MasonryPostRsp = {
              postId: v.postId,
              userId: v.userId,
              postContent: postContent.content,
              postContentType: postContent.postContentType,
              username: v.username,
              location: v.location,
              previewImg: postContent.previewImg,
              videoDuration: postContent.videoDuration,
              isUploaded: postContent.isUploaded,
            };

            const src =
              masonryPostRsp.postContentType === POST_IMAGE_TYPE
                ? postContent.content
                : postContent.previewImg;

            img.src = src;

            img.onload = () => {
              const aspectRatio = img.naturalHeight / img.naturalWidth;
              const fixedWidth = 190; // columnWidth 기준
              const height = fixedWidth * aspectRatio;
              console.log(height);
              resolve({
                id: v.postId,
                src,
                height: height,
                postInfo: v,
              });
            };
            img.onerror = () => {
              // 실패 시 기본값
              resolve({
                id: v.postId,
                src,
                height: 180,
                postInfo: v,
              });
            };
          }),
      );
      const loadedItems = await Promise.all(promises);
      const validItems = loadedItems.filter(
        (item): item is Item =>
          !!item &&
          typeof item.id === 'string' &&
          typeof item.src === 'string' &&
          typeof item.height === 'number' &&
          !!item.postInfo,
      );

      setItems(masonryKey >= 1 ? [] : validItems);

      console.log('요소', masonryKey);
      console.log('요소 체크:', validItems);
      // setItems(loadedItems);
    };

    loadImages();
  }, [snsPostList]);

  const positioner = usePositioner({
    width,
    columnWidth: 190,
    columnGutter: 10,
    rowGutter: 5,
  });

  const { scrollTop, isScrolling } = useScroller(offset);
  const navigate = useNavigate();

  const RenderCard = React.useCallback(({ data }: { data: Item }) => {
    const postContent = data.postInfo.postContents[0];

    const masonryPostRsp: MasonryPostRsp = {
      postId: data.postInfo.postId,
      userId: data.postInfo.userId,
      postContent: postContent.content,
      postContentType: postContent.postContentType,
      username: data.postInfo.username,
      location: data.postInfo.location,
      previewImg: postContent.previewImg,
      videoDuration: postContent.videoDuration,
      isUploaded: postContent.isUploaded,
    };
    return (
      <Card
        style={{ height: data.height }}
        onClick={() => {
          const searchParams = new URLSearchParams(location.search);

          // 새로운 쿼리 파라미터 추가 또는 기존 파라미터 값 수정
          searchParams.set(POST_DETAIL_POPUP_PARAM, TRUE_PARAM);
          searchParams.set(POST_DETAIL_POST_ID_PARAM, data.postInfo.postId);
          searchParams.set(POST_DETAIL_PROFILE_PARAM, data.postInfo.username);

          // 새로운 쿼리 파라미터가 포함된 URL 생성
          const newSearch = searchParams.toString();
          const newPath =
            `${location.pathname}?${newSearch}` +
            (searchType ? `&${SEARCH_TYPE_PARAM}=${searchType}` : '');

          navigate(newPath, {
            replace: linkPopupInfo.isReplaced,
            state: { isDetailPopup: true },
          });
        }}
      >
        <PostImagePreviewElementV2
          imageSrc={
            masonryPostRsp.postContentType === POST_IMAGE_TYPE
              ? masonryPostRsp.postContent
              : masonryPostRsp.previewImg
          }
          actionFuncByRef={actionFuncByRef}
          PostImageStyle={{
            borderRadius: `${ContentBorderRadius}px`,
          }}
          selectPostRsp={data.postInfo}
          scrapId={scrapId}
          // onError={() => handleImageError(v.postId)}
          location={masonryPostRsp.location}
          ContentBorderRadius={ContentBorderRadius}
          longPressToResizeNum={longPressToResizeNum}
        />
      </Card>
    );
  }, []);

  const masonry = useMasonry({
    positioner,
    scrollTop,
    isScrolling,
    // itemKey: (item) => {
    //   if (!item || !item.id) {
    //     console.warn('Invalid item in itemKey:', item);
    //     return `invalid-${Math.random()}`; // fallback key
    //   }
    //   return item.id;
    // },
    height: windowHeight,
    containerRef,
    items,
    overscanBy: 3,
    render: RenderCard,
  });
  const [a, b] = useForceUpdate();
  useEffect(() => {
    a();
  }, [masonryKey]);

  return (
    <Container ref={containerRef} key={masonryKey}>
      {masonry}
    </Container>
  );
};

const ContentBorderRadius = 22;

// 스타일 컴포넌트
const Container = styled.div`
  // max-width: 960px;
  margin: 0 5px; /* 좌우 5px padding */
  // margin: 0 auto;
`;

const Card = styled.div`
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  transition: transform 100ms ease-in-out;
  width: 100%;
`;

const ImageWrapper = styled.div`
  width: 100%;
  height: calc(100% - 20px);
  img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-top-left-radius: 16px;
    border-top-right-radius: 16px;
  }
`;

// 유틸: 윈도우 사이즈
function useWindowSize(): [number, number] {
  const [size, setSize] = React.useState<[number, number]>([
    window.innerWidth,
    window.innerHeight,
  ]);
  React.useLayoutEffect(() => {
    const handleResize = () => setSize([window.innerWidth, window.innerHeight]);
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);
  return size;
}

const PostSettingDotButtonContainer = styled.div`
  display: flex;
  justify-content: end;
  position: relative;
  flex-shrink: 1;
`;

const PostSettingDotButtonWrap = styled.div`
  display: flex;
  margin: auto 0px;
  cursor: pointer;
  position: relative;

  @media (min-width: ${MEDIA_MOBILE_MAX_WIDTH}) {
    ${hoverRoundCoverStyle}
  }
`;

const PostSettingDotButtonSubWrap = styled.div`
  display: flex;
  &::before {
    content: '';
    position: absolute;
    top: -15px;
    bottom: -15px;
    left: -15px;
    right: 0px;
    z-index: -1; /* 가상 요소를 버튼 뒤로 배치 */
    background: transparent; /* 투명 */
  }
`;

export default MasonicLayout;
